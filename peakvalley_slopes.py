# -*- coding: utf-8 -*-
"""PeakValley_Slopes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Y6AkpqidK3mFrcigBZfuSxQ3rcGe_H1V

## **Import Data**
"""



# Commented out IPython magic to ensure Python compatibility.
#@title
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.widgets import SpanSelector
from plotly.offline import iplot
#from google.colab import files
from tkinter import *
from tkinter import filedialog

def openFile():
    filepath = filedialog.askopenfilename()
    file = open(filepath,'r')
    print(file.read())
    file.close()
window = Tk()
button = Button(text="Open", command=openFile)
button.pack()
window.mainloop

# %matplotlib inline

#@title
# Import .csv (cal) file, change name for each file

print('Upload Data','\n') 
excel_file = input("Select File (.xlsx) : ")
if excel_file.find('.') == -1:
  excel_file = excel_file + '.xlsx'

if excel_file.find('/') == -1: 
  path = 0
else:
  path = excel_file.find('/')

extension = excel_file.find('.')

data_input = pd.read_excel(excel_file)
dataset = pd.DataFrame(data_input)

#@title
time = np.array(dataset.iloc[:,0])
relative_x = np.array(dataset.iloc[:,4])
relative_y = np.array(dataset.iloc[:,5])
relative_z = np.array(dataset.iloc[:,6])

time_updated = relative_x_updated = relative_y_updated = relative_z_updated = []

for i in range(len(time)):
  if str(relative_x[i]) != 'nan' and str(relative_y[i]) != 'nan' and str(relative_z[i]) != 'nan':

    time_updated = np.append(time_updated,time[i])
    relative_x_updated = np.append(relative_x_updated,relative_x[i])
    relative_y_updated = np.append(relative_y_updated,relative_y[i])
    relative_z_updated = np.append(relative_z_updated,relative_z[i])

time = np.array(time_updated)
relative_x = np.array(relative_x_updated)
relative_y = np.array(relative_y_updated)
relative_z = np.array(relative_z_updated)

scaled_relative_x = relative_x[:] - relative_x[0]
scaled_relative_y = relative_y[:] - relative_y[0]
scaled_relative_z = relative_z[:] - relative_z[0]
total_distance_3D = np.sqrt(np.square(scaled_relative_x[:]) + np.square(scaled_relative_y[:]) + np.square(scaled_relative_z[:]))

raw_x = scaled_relative_x
raw_y = scaled_relative_y
raw_z = scaled_relative_z
raw_3D = total_distance_3D

"""## **X-Direction**

Generate interactive plot (iplot) and select the 'Toggle Spine Lines' button (3rd from left in top right of plot). Hover over data points for the range you want to analyze. Then plug these values in for the time start and stop values.
"""

#@title
# Configure interactive plot
raw_x_plt = iplot([{'x': time,'y' : raw_x}])

#@title
def Selected_time_range(time_start, time_stop):

  delta_start = abs(time - time_start)
  delta_stop = abs(time - time_stop)

  start = np.where(delta_start == min(delta_start))[0][0]
  stop = np.where(delta_stop == min(delta_stop))[0][0]
  
  print('\n','start index : ', start, '\t', 'actual start time (sec): ', time[start])
  print(      'stop index : ', stop,  '\t', 'actual stop time (sec): ' , time[stop] )
  return start, stop

#@title
print('Select your start and end time points to analyze','\n') 

x_time_start = float(input("Enter start time (sec): ")) # Time Start (1st data point in range)
x_time_stop = float(input("Enter end time (sec): ")) # Time Stop (last data point in range)

[x_start, x_stop] = Selected_time_range(x_time_start, x_time_stop)

#@title
def smoothen(x, winsize):
    return np.array(pd.Series(x).rolling(winsize).mean())[winsize-1:]
    
smooth_ans = input('Smoothen Data (Y/N): ')

satisfied_ans = 0

if isinstance(smooth_ans, (str)):
  if smooth_ans == 'Y' or smooth_ans == 'y' or smooth_ans == 'yes' or smooth_ans == 'Yes' or smooth_ans == 'YES':
    winsize = int(input('Enter window size (integer): '))
    temp_time = smoothen(time, winsize)
    temp_raw_x = smoothen(raw_x, winsize)
    temp_raw_y = smoothen(raw_y, winsize)
    temp_raw_z = smoothen(raw_z, winsize)
    temp_raw_3D = smoothen(raw_3D, winsize)
    
    # Configure interactive plot
    temp_raw_x_plt = iplot([{'x': temp_time,'y' : temp_raw_x}])
    satisfied_ans = 1
else:
  print('Please enter "Y" or "N"','\n')

#@title

if satisfied_ans == 1: 
  satisfied = input('Satisfied (Y/N): ')
  if isinstance(satisfied, (str)):
    if satisfied == 'Y' or satisfied == 'y' or satisfied == 'yes' or satisfied == 'Yes' or satisfied == 'YES':
      time = temp_time
      raw_x = temp_raw_x
      raw_y = temp_raw_y
      raw_z = temp_raw_z
      raw_3D = temp_raw_3D
    else:
      print('Please enter "Y" or "N"','\n')

#@title
def Select_data_range(start, stop, raw_data):
  
  y_start = start
  y_stop = stop
  print('Start index: ', y_start, '\t', 'Stop index: ', y_stop)

  y_data = raw_data[y_start:y_stop]
  t_data = time[y_start:y_stop]

  peaks = valleys = p_t = v_t = np.array([])
  
  for i in range(len(y_data)-1):

    if i > 0 and i < len(y_data)-2:
      
      if y_data[i] > y_data[i-2] and y_data[i] > y_data[i-1] and y_data[i] > y_data[i+1] and y_data[i] > y_data[i+2]:
        peaks_new = y_data[i]
        p_t_new = t_data[i]
        peaks = np.append(peaks, peaks_new)
        p_t = np.append(p_t, p_t_new)

      elif y_data[i] < y_data[i-2] and y_data[i] < y_data[i-1] and y_data[i] < y_data[i+1] and y_data[i] < y_data[i+2]:
        valleys_new = y_data[i]
        v_t_new = t_data[i]
        valleys = np.append(valleys, valleys_new)
        v_t = np.append(v_t, v_t_new)
    
    elif i == 0:
      
      if y_data[i] > y_data[i+1] and y_data[i] > y_data[i+2] and y_data[i] > y_data[i+3]: 
        peaks_new = y_data[i]
        p_t_new = t_data[i]
        peaks = np.append(peaks, peaks_new)
        p_t = np.append(p_t, p_t_new)
      
      elif y_data[i] < y_data[i+1] and y_data[i] < y_data[i+2] and y_data[i] < y_data[i+3]:
        valleys_new = y_data[i]
        v_t_new = t_data[i]
        valleys = np.append(valleys, valleys_new)
        v_t = np.append(v_t, v_t_new)
    
    elif i == len(y_data)-2:

      if y_data[i] > y_data[i-1] and y_data[i] > y_data[i-2] and y_data[i] > y_data[i+1]:
        peaks_new = y_data[i]
        p_t_new = t_data[i]
        peaks = np.append(peaks, peaks_new)
        p_t = np.append(p_t, p_t_new)

      elif y_data[i] < y_data[i-1] and y_data[i] < y_data[i-2] and y_data[i] < y_data[i+1]:
        valleys_new = y_data[i]
        v_t_new = t_data[i]
        valleys = np.append(valleys, valleys_new)
        v_t = np.append(v_t, v_t_new)

    elif i == len(y_data)-1:
      
      if y_data[i] > y_data[i-1] and y_data[i] > y_data[i-2] and y_data[i] > y_data[i-3]:
        peaks_new = y_data[i]
        p_t_new = t_data[i]
        peaks = np.append(peaks, peaks_new)
        p_t = np.append(p_t, p_t_new)

      elif y_data[i] < y_data[i-1] and y_data[i] < y_data[i-2] and y_data[i] < y_data[i-3]:
        valleys_new = y_data[i]
        v_t_new = t_data[i]
        valleys = np.append(valleys, valleys_new)
        v_t = np.append(v_t, v_t_new)
    
    if peaks.shape[0] > 0 and valleys.shape[0] > 0:
      thresh = 50 # mm 
      if peaks[len(peaks)-1] >= thresh or valleys[len(valleys)-1] <= -thresh:
        peaks = peaks[:-1]
        valleys = valleys[:-1]
        p_t = p_t[:-1]
        v_t = v_t[:-1]

  if len(peaks) > len(valleys):
    print('# Peaks: ', peaks.shape[0])
    print('# Valleys: ', valleys.shape[0])

    diff = len(peaks) - len(valleys)
    new_peaks = new_valleys = new_p_t = new_v_t = [] 
    for j in range(len(p_t)):
      pv_pair = abs(v_t - p_t[j]) 
      # Find index of the peaks closest to the particular valley in terms of time
      pair_idx = np.where(pv_pair == min(pv_pair))[0][0]
      
      if abs(v_t[pair_idx]-p_t[j]) <= 1:
        new_v_t = np.append(v_t[pair_idx], new_v_t)
        new_valleys = np.append(valleys[pair_idx], new_valleys)
        new_p_t = np.append(p_t[j], new_p_t)
        new_peaks = np.append(peaks[j], new_peaks)

    print(new_v_t.shape)

    p_t = new_p_t
    peaks = new_peaks
    v_t = new_v_t
    valleys = new_valleys
  
  elif len(peaks) < len(valleys):
    print('# Peaks: ', peaks.shape[0])
    print('# Valleys: ', valleys.shape[0])
    
    diff = len(valleys) - len(peaks)
    new_peaks = new_valleys = new_p_t = new_v_t = [] 
    for j in range(len(v_t)):
      pv_pair = abs(p_t - v_t[j]) 
      # Find index of the peaks closest to the particular valley in terms of time
      pair_idx = np.where(pv_pair == min(pv_pair))[0][0]
      
      if abs(p_t[pair_idx]-v_t[j]) <= 1:
        new_p_t = np.append(p_t[pair_idx], new_p_t)
        new_peaks = np.append(peaks[pair_idx], new_peaks)
        new_v_t = np.append(v_t[j], new_v_t)
        new_valleys = np.append(valleys[j], new_valleys)

    print(new_p_t.shape)
    # Drop the overhang
    #p_t = new_p_t[:-diff]
    #peaks = new_peaks[:-diff]
    #v_t = v_t[:-diff]
    #valleys = valleys[:-diff]
    
    p_t = new_p_t
    peaks = new_peaks
    v_t = new_v_t
    valleys = new_valleys

    #diff = len(valleys) - len(peaks)
    #valleys = valleys[0:-diff]
    #v_t = v_t[0:-diff]
    #print(diff)
    #stop_overhang = abs(v_t[:-diff] - p_t[:len(p_t)])
    #print(p_t[len(p_t)-1])
    #print(v_t[len(v_t)-1])
    #print(v_t[len(v_t)-1-diff])
    #stop_adj = np.where(stop_overhang == min(stop_overhang))[0][0]
    #valleys = valleys[0:stop_adj+1]
    #print(v_t[:-diff].shape)
    #v_t = v_t[0:stop_adj+1]
  print(p_t.shape)
  print(v_t.shape)
    #print(stop_overhang[len(stop_overhang)-1])
    #print(stop_adj)
    #print(v_t[len(v_t)-1])

  peak_valleys = abs(peaks - valleys) 
  print(peaks.shape)
  print(valleys.shape)
  print(peak_valleys.shape)
  # Take the time of the inflection point (flip between peak and valley) as 
  # the time point for PV

  stack = np.vstack((p_t,v_t)) # Create an (n,2) array
  t_pv = abs((p_t - v_t)/2) + np.min(stack,axis=0) # find average between time
  # points of peak and valley, then add that average to the lowest time point
  # of the two (offset)

  delta_PV = abs(peak_valleys[1] - peak_valleys[len(peak_valleys)-20])
  return delta_PV, peak_valleys, t_pv, peaks, valleys, p_t, v_t, y_data, t_data

#@title
[x_delta_PV, x_peak_valleys, x_t_pv, x_peaks, x_valleys, x_p_t, x_v_t, x_data, x_t_data] = Select_data_range(x_start, x_stop, raw_x)

# Configure interactive plot
raw_x_plt = iplot([{'x': time,'y' : raw_x},{'x': x_p_t,'y': x_peaks}, {'x': x_v_t, 'y': x_valleys}])

#@title
# Plot and save matlablib plot of raw data for future reference
plt.figure(figsize=(20, 9))
plt.plot(time, raw_x, linewidth=1)
plt.plot(x_p_t, x_peaks, 'r-', x_v_t, x_valleys, 'g-', linewidth=0.8)
plt.plot([x_t_pv[1], x_t_pv[1], x_t_pv[1], x_t_pv[1], x_t_pv[1]],
         np.linspace(np.min(raw_x),np.max(raw_x),5),'m--',
         [x_t_pv[len(x_t_pv)-20], x_t_pv[len(x_t_pv)-20], x_t_pv[len(x_t_pv)-20],
          x_t_pv[len(x_t_pv)-20], x_t_pv[len(x_t_pv)-20]],
         np.linspace(np.min(raw_x),np.max(raw_x),5),'m--',
         linewidth=2)
plt.xlabel('Time (sec)')
plt.ylabel('Displacement (X-dir, mm)')
plt.title('Toggle X-dir')
plt.legend(['Raw-X','Peaks','Valleys','Range of Interest (ROI)'])

fig_name = excel_file[path:extension] + '- Fig Raw-X Data.png'
print(fig_name)

plt.savefig(fig_name)
#files.download(fig_name)

#@title
plt.figure(figsize=(15, 8))
plt.plot(x_p_t, x_peaks,'o-', x_v_t, x_valleys,'*-')
plt.xlabel('Time (sec)')
plt.ylabel('Displacement (X-dir, mm)')
plt.title('Toggle X-dir')
plt.legend(['Peaks','Valleys'])
print('Change in PV Displacement : ', round(x_delta_PV,4), ' mm')

fig_name = excel_file[path:extension] + '- Fig Peaks vs. Valley X-Dir.png'
print(fig_name)

plt.savefig(fig_name)
#files.download(fig_name)

"""**Linear Regression**"""

#@title
plt.figure(figsize=(15, 6))
plt.plot(x_t_pv,x_peak_valleys,'*',[x_t_pv[1], x_t_pv[1], x_t_pv[1], x_t_pv[1], x_t_pv[1]],
         np.linspace(np.min(x_peak_valleys),np.max(x_peak_valleys),5),'m--',
         [x_t_pv[len(x_t_pv)-20], x_t_pv[len(x_t_pv)-20], x_t_pv[len(x_t_pv)-20],
          x_t_pv[len(x_t_pv)-20], x_t_pv[len(x_t_pv)-20]],
         np.linspace(np.min(x_peak_valleys),np.max(x_peak_valleys),5),'m--',
         linewidth=2)
plt.xlabel('Time (sec)')
plt.ylabel('Displacement (x-dir, mm)')
plt.title('Toggle X-dir: Peak-Valleys')
plt.legend(['Peak-Valleys (PV)','Region of Interest (ROI)'])

fig_name = excel_file[path:extension] + '- Fig Peak-Valleys X-Dir.png'
print(fig_name)

plt.savefig(fig_name)
#files.download(fig_name)

#@title
from sklearn.linear_model import LinearRegression

x = x_t_pv.reshape(-1,1)
y = x_peak_valleys.reshape(-1,1)
model = LinearRegression().fit(x, y)
x_r_2 = model.score(x, y)
x_int = model.intercept_[0]
x_slope = model.coef_[0][0]
print('coefficient of determination (R-squared):', round(x_r_2,4))
print('intercept:', round(x_int,4))
print('slope:', round(x_slope,4))

#@title
# Generate prediction based on linear regression model
# linear_fit = x * slope + y_int
y_shape = x_peak_valleys.shape
y_pred = model.predict(x)
y_pred = y_pred.reshape(y_shape)

"""**Exponential Regression**"""

#@title
# Scientific libraries
from scipy.optimize import curve_fit

def exponenial_regression(x, a, b, c):
    return a * np.exp(-b * x) + c

x = x_t_pv
y = x_peak_valleys

x_popt, pcov = curve_fit(exponenial_regression, x, y, p0=(1, 1e-3, 1))

xx = np.linspace(x_time_start, x_time_stop, len(y)+1) 
yy = exponenial_regression(xx, *x_popt)

# Calcualting R-squared

residuals = y- exponenial_regression(x, *x_popt)
ss_res = np.sum(residuals**2)
ss_tot = np.sum((y - np.mean(y))**2)
x_r_2_exp = 1 - (ss_res / ss_tot)

#@title
plt.figure(figsize=(15, 6))
plt.plot(x_t_pv, x_peak_valleys, '*', x_t_pv, y_pred, 'r-', xx, yy, 'k-', linewidth=4)
plt.xlabel('Time (sec)')
plt.ylabel('Displacement (X-dir, mm)')
plt.title('Toggle X-dir: Peak-Valleys')
plt.legend(['Peak-Valleys (PV)','Linear Fit','Exponential Fit'])

fig_name = excel_file[path:extension] + '- Fig Peak-Valleys Trend X-Dir.png'
print(fig_name)

plt.savefig(fig_name)
#files.download(fig_name)

print('\n','                                          Linear Fit: y = x * (', round(x_slope,4), ') + (', round(x_int,4),')\n')
print('                                                      R-squared: ', round(x_r_2,4),'\n')
print('\n','                                Exponential Fit: y = ', round(x_popt[0],4), '* exp(', -1*round(x_popt[1],4), ' * x) + ', round(x_popt[2],4), '\n')
print('                                                      R-squared: ', round(x_r_2_exp,4),'\n')

"""## **Y-Direction**
Generate interactive plot (iplot) and hover over data points for the range you want to analyze. Then plug these values in for the time start and stop values.
"""

#@title
raw_y_plt = iplot([{'x': time,'y' : raw_y}])

#@title
print('Select your start and end time points to analyze','\n') 

#y_time_start = float(input("Enter start time (sec): ")) # Time Start (1st data point in range)
#y_time_stop = float(input("Enter end time (sec): " )) # Time Stop (last data point in range)
y_time_start = x_time_start
y_time_stop = x_time_stop
[y_start, y_stop] = Selected_time_range(y_time_start, y_time_stop)

#@title
[y_delta_PV, y_peak_valleys, y_t_pv, y_peaks, y_valleys, y_p_t, y_v_t, y_data, y_t_data] = Select_data_range(y_start, y_stop, raw_y)

# Configure interactive plot
raw_y_plt = iplot([{'x': time,'y' : raw_y},{'x': y_p_t,'y': y_peaks}, {'x': y_v_t, 'y': y_valleys}])

#@title
# Plot and save matlablib plot of raw data for future reference
plt.figure(figsize=(20, 9))
plt.plot(time, raw_y, linewidth=1)
plt.plot(y_p_t, y_peaks, 'r-', y_v_t, y_valleys, 'g-', linewidth=0.8)
plt.plot([y_t_pv[1], y_t_pv[1], y_t_pv[1], y_t_pv[1], y_t_pv[1]],
         np.linspace(np.min(raw_y),np.max(raw_y),5),'m--',
         [y_t_pv[len(y_t_pv)-20], y_t_pv[len(y_t_pv)-20], y_t_pv[len(y_t_pv)-20],
          y_t_pv[len(y_t_pv)-20], y_t_pv[len(y_t_pv)-20]],
         np.linspace(np.min(raw_y),np.max(raw_y),5),'m--',
         linewidth=2)
plt.xlabel('Time (sec)')
plt.ylabel('Displacement (Y-dir, mm)')
plt.title('Toggle Y-dir')
plt.legend(['Raw-Y','Peaks','Valleys','Range of Interest (ROI)'])

fig_name = excel_file[path:extension] + '- Fig Raw-Y Data.png'
print(fig_name)

plt.savefig(fig_name)
#files.download(fig_name)

#@title
plt.figure(figsize=(15, 8))
plt.plot(y_p_t, y_peaks,'o-', y_v_t, y_valleys,'*-')
plt.xlabel('Time (sec)')
plt.ylabel('Displacement (Y-dir, mm)')
plt.title('Toggle Y-dir')
plt.legend(['Peaks','Valleys'])
print('Change in PV Displacement : ', round(y_delta_PV,4), ' mm')

fig_name = excel_file[path:extension] + '- Fig Peaks vs. Valley Y-Dir.png'
print(fig_name)

plt.savefig(fig_name)
#files.download(fig_name)

"""**Linear Regression**"""

#@title
plt.figure(figsize=(15, 6))
plt.plot(y_t_pv,y_peak_valleys,'*',[y_t_pv[1], y_t_pv[1], y_t_pv[1], y_t_pv[1], y_t_pv[1]],
         np.linspace(np.min(y_peak_valleys),np.max(y_peak_valleys),5),'m--',
         [y_t_pv[len(y_t_pv)-20], y_t_pv[len(y_t_pv)-20], y_t_pv[len(y_t_pv)-20],
          y_t_pv[len(y_t_pv)-20], y_t_pv[len(y_t_pv)-20]],
         np.linspace(np.min(y_peak_valleys),np.max(y_peak_valleys),5),'m--',
         linewidth=2)
plt.xlabel('Time (sec)')
plt.ylabel('Displacement (y-dir, mm)')
plt.title('Toggle Y-dir: Peak-Valleys')
plt.legend(['Peak-Valleys (PV)','Range of Interest (ROI)'])

fig_name = excel_file[path:extension] + '- Fig Peak-Valleys Y-Dir.png'
print(fig_name)

plt.savefig(fig_name)
#files.download(fig_name)

#@title
from sklearn.linear_model import LinearRegression

x = y_t_pv.reshape(-1,1)
y = y_peak_valleys.reshape(-1,1)
model = LinearRegression().fit(x, y)
y_r_2 = model.score(x, y)
y_int = model.intercept_[0]
y_slope = model.coef_[0][0]
print('coefficient of determination (R-squared):', round(y_r_2,4))
print('intercept:', round(y_int,4))
print('slope:', round(y_slope,4))

#@title
# Generate prediction based on linear regression model
# linear_fit = x * slope + y_int
y_shape = y_peak_valleys.shape
y_pred = model.predict(x)
y_pred = y_pred.reshape(y_shape)

"""**Exponential Regression**"""

#@title
x = y_t_pv
y = y_peak_valleys

y_popt, pcov = curve_fit(exponenial_regression, x, y, p0=(1, 2e-3, 1))

xx = np.linspace(y_time_start, y_time_stop, len(y)+1) 
yy = exponenial_regression(xx, *y_popt)

# Calcualting R-squared

residuals = y- exponenial_regression(x, *y_popt)
ss_res = np.sum(residuals**2)
ss_tot = np.sum((y - np.mean(y))**2)
y_r_2_exp = 1 - (ss_res / ss_tot)

#@title
plt.figure(figsize=(15, 6))
plt.plot(y_t_pv, y_peak_valleys, '*', y_t_pv, y_pred, 'r-', xx, yy, 'k-', linewidth=4)
plt.xlabel('Time (sec)')
plt.ylabel('Displacement (Y-dir, mm)')
plt.title('Toggle Y-dir: Peak-Valleys')
plt.legend(['Peak-Valleys (PV)','Linear Fit','Exponential Fit'])

fig_name = excel_file[path:extension] + '- Fig Peak-Valleys Trend Y-Dir.png'
print(fig_name)

plt.savefig(fig_name)
#files.download(fig_name)

print('\n','                                          Linear Fit: y = x * (', round(y_slope,4), ') + (', round(y_int,4),')\n')
print('                                                      R-squared: ', round(y_r_2,4),'\n')
print('\n','                                Exponential Fit: y = ', round(y_popt[0],4), '* exp(', -1*round(y_popt[1],4), ' * x) + ', round(y_popt[2],4), '\n')
print('                                                      R-squared: ', round(y_r_2_exp,4),'\n')

"""##**Z-Direction**
Generate interactive plot (iplot) and hover over data points for the range you want to analyze. Then plug these values in for the time start and stop values.

"""

#@title
raw_z_plt = iplot([{'x': time,'y' : raw_z}])

#@title
print('Select your start and end time points to analyze','\n') 

#z_time_start = float(input("Enter start time (sec): ")) # Time Start (1st data point in range)
#z_time_stop = float(input("Enter end time (sec): " )) # Time Stop (last data point in range)
z_time_start = x_time_start
z_time_stop = x_time_stop
[z_start, z_stop] = Selected_time_range(z_time_start, z_time_stop)

#@title
[z_delta_PV, z_peak_valleys, z_t_pv, z_peaks, z_valleys, z_p_t, z_v_t, z_data, z_t_data] = Select_data_range(z_start, z_stop, raw_z)

# Configure interactive plot
raw_z_plt = iplot([{'x': time,'y' : raw_z},{'x': z_p_t,'y': z_peaks}, {'x': z_v_t, 'y': z_valleys}])

#@title
# Plot and save matlablib plot of raw data for future reference
plt.figure(figsize=(20, 9))
plt.plot(time, raw_z, linewidth=1)
plt.plot(z_p_t, z_peaks, 'r-', z_v_t, z_valleys, 'g-', linewidth=0.8)
plt.plot([z_t_pv[1], z_t_pv[1], z_t_pv[1], z_t_pv[1], z_t_pv[1]],
         np.linspace(np.min(raw_z),np.max(raw_z),5),'m--',
         [z_t_pv[len(z_t_pv)-20], z_t_pv[len(z_t_pv)-20], z_t_pv[len(z_t_pv)-20],
          z_t_pv[len(z_t_pv)-20], z_t_pv[len(z_t_pv)-20]],
         np.linspace(np.min(raw_z),np.max(raw_z),5),'m--',
         linewidth=2)
plt.xlabel('Time (sec)')
plt.ylabel('Displacement (Z-dir, mm)')
plt.title('Toggle Z-dir')
plt.legend(['Raw-Z','Peaks','Valleys','Range of Interest (ROI)'])

fig_name = excel_file[path:extension] + '- Fig Raw-Z Data.png'
print(fig_name)

plt.savefig(fig_name)
#files.download(fig_name)

#@title
plt.figure(figsize=(15, 8))
plt.plot(z_p_t, z_peaks,'o-', z_v_t, z_valleys,'*-')
plt.xlabel('Time (sec)')
plt.ylabel('Displacement (Z-dir, mm)')
plt.title('Toggle Z-dir')
plt.legend(['Peaks','Valleys'])
print('Change in PV Displacement : ', round(z_delta_PV,4), ' mm')

fig_name = excel_file[path:extension] + '- Fig Peaks vs. Valley Z-Dir.png'
print(fig_name)

plt.savefig(fig_name)
#files.download(fig_name)

"""**Linear Regression**"""

#@title
plt.figure(figsize=(15, 6))
plt.plot(z_t_pv,z_peak_valleys,'*',[z_t_pv[1], z_t_pv[1], z_t_pv[1], z_t_pv[1], z_t_pv[1]],
         np.linspace(np.min(z_peak_valleys),np.max(z_peak_valleys),5),'m--',
         [z_t_pv[len(z_t_pv)-20], z_t_pv[len(z_t_pv)-20], z_t_pv[len(z_t_pv)-20],
          z_t_pv[len(z_t_pv)-20], z_t_pv[len(z_t_pv)-20]],
         np.linspace(np.min(z_peak_valleys),np.max(z_peak_valleys),5),'m--',
         linewidth=2)
plt.xlabel('Time (sec)')
plt.ylabel('Displacement (z-dir, mm)')
plt.title('Toggle Z-dir: Peak-Valleys')
plt.legend(['Peaks-Valleys (PV)','Range of Interest (ROI)'])

fig_name = excel_file[path:extension] + '- Fig Peak-Valleys Z-Dir.png'
print(fig_name)

plt.savefig(fig_name)
#files.download(fig_name)

#@title
from sklearn.linear_model import LinearRegression

x = z_t_pv.reshape(-1,1)
y = z_peak_valleys.reshape(-1,1)
model = LinearRegression().fit(x, y)
z_r_2 = model.score(x, y)
z_int = model.intercept_[0]
z_slope = model.coef_[0][0]
print('coefficient of determination (R-squared):', round(z_r_2,4))
print('intercept:', round(z_int,4))
print('slope:', round(z_slope,4))

#@title
# Generate prediction based on linear regression model
# linear_fit = x * slope + y_int
y_shape = z_peak_valleys.shape
y_pred = model.predict(x)
y_pred = y_pred.reshape(y_shape)

"""**Exponential Regression**"""

#@title
x = z_t_pv
y = z_peak_valleys

z_popt, pcov = curve_fit(exponenial_regression, x, y, p0=(1, 1e-3, 1))

xx = np.linspace(z_time_start, z_time_stop, len(y)+1) 
yy = exponenial_regression(xx, *z_popt)

# Calcualting R-squared
residuals = y - exponenial_regression(x, *z_popt)
ss_res = np.sum(residuals**2)
ss_tot = np.sum((y - np.mean(y))**2)
z_r_2_exp = 1 - (ss_res / ss_tot)

#@title
plt.figure(figsize=(15, 6))
plt.plot(z_t_pv, z_peak_valleys, '*', z_t_pv, y_pred, 'r-', xx, yy, 'k-', linewidth=4)
plt.xlabel('Time (sec)')
plt.ylabel('Displacement (z-dir, mm)')
plt.title('Toggle Z-dir: Peak-Valleys')
plt.legend(['Peak-Valleys (PV)','Linear Fit','Exponential Fit'])

fig_name = excel_file[path:extension] + '- Fig Peak-Valleys Trend Z-Dir.png'
print(fig_name)

plt.savefig(fig_name)
#files.download(fig_name)

print('\n','                                          Linear Fit: y = x * (', round(z_slope,4), ') + (', round(z_int,4),')\n')
print('                                                      R-squared: ', round(z_r_2,4),'\n')
print('\n','                                Exponential Fit: y = ', round(z_popt[0],4), '* exp(', -1*round(z_popt[1],4), ' * x) + ', round(z_popt[2],4), '\n')
print('                                                      R-squared: ', round(z_r_2_exp,4),'\n')

"""## **3D-Direction**
Generate interactive plot (iplot) and hover over data points for the range you want to analyze. Then plug these values in for the time start and stop values.
"""

#@title
raw_3D_plt = iplot([{'x': time,'y' : raw_3D}])

#@title
print('Select your start and end time points to analyze','\n') 

#threeD_time_start = float(input("Enter start time (sec): ")) # Time Start (1st data point in range)
#threeD_time_stop = float(input("Enter end time (sec): " )) # Time Stop (last data point in range)
threeD_time_start = x_time_start
threeD_time_stop = x_time_stop
[threeD_start, threeD_stop] = Selected_time_range(threeD_time_start, threeD_time_stop)

#@title
[threeD_delta_PV, threeD_peak_valleys, threeD_t_pv, threeD_peaks, threeD_valleys, threeD_p_t, threeD_v_t, threeD_data, threeD_t_data] = Select_data_range(threeD_start, threeD_stop, raw_3D)

# Configure interactive plot
raw_3D_plt = iplot([{'x': time,'y' : raw_3D},{'x': threeD_p_t,'y': threeD_peaks}, {'x': threeD_v_t, 'y': threeD_valleys}])

#@title
# Plot and save matlablib plot of raw data for future reference
plt.figure(figsize=(20, 9))
plt.plot(time, raw_3D, linewidth=1)
plt.plot(threeD_p_t,threeD_peaks, 'r-', threeD_v_t, threeD_valleys, 'g-', linewidth=0.8)
plt.plot([threeD_t_pv[1], threeD_t_pv[1], threeD_t_pv[1], threeD_t_pv[1], threeD_t_pv[1]],
         np.linspace(np.min(raw_3D),np.max(raw_3D),5),'m--',
         [threeD_t_pv[len(threeD_t_pv)-20], threeD_t_pv[len(threeD_t_pv)-20], threeD_t_pv[len(threeD_t_pv)-20],
          threeD_t_pv[len(threeD_t_pv)-20], threeD_t_pv[len(threeD_t_pv)-20]],
         np.linspace(np.min(raw_3D),np.max(raw_3D),5),'m--',
         linewidth=2)
plt.xlabel('Time (sec)')
plt.ylabel('Displacement (3D-dir, mm)')
plt.title('Toggle 3D-dir')
plt.legend(['Raw-3D','Peaks','Valleys','Range of Interest (ROI)'])

fig_name = excel_file[path:extension] + '- Fig Raw-3D Data.png'
print(fig_name)

plt.savefig(fig_name)
#files.download(fig_name)

#@title
plt.figure(figsize=(15, 8))
plt.plot(threeD_p_t, threeD_peaks,'o-', threeD_v_t, threeD_valleys,'*-')
plt.xlabel('Time (sec)')
plt.ylabel('Displacement (3D, mm)')
plt.title('Toggle 3D')
plt.legend(['Peaks','Valleys'])
print('Change in PV Displacement : ', round(threeD_delta_PV,4), ' mm')

fig_name = excel_file[path:extension] + '- Fig Peaks vs. Valley 3D-Dir.png'
print(fig_name)

plt.savefig(fig_name)
#files.download(fig_name)

"""**Linear Regression**"""

#@title
plt.figure(figsize=(15, 6))
plt.plot(threeD_t_pv,threeD_peak_valleys,'*',[threeD_t_pv[1], threeD_t_pv[1], threeD_t_pv[1], threeD_t_pv[1], threeD_t_pv[1]],
         np.linspace(np.min(threeD_peak_valleys),np.max(threeD_peak_valleys),5),'m--',
         [threeD_t_pv[len(threeD_t_pv)-20], threeD_t_pv[len(threeD_t_pv)-20], threeD_t_pv[len(threeD_t_pv)-20],
          threeD_t_pv[len(threeD_t_pv)-20], threeD_t_pv[len(threeD_t_pv)-20]],
         np.linspace(np.min(threeD_peak_valleys),np.max(threeD_peak_valleys),5),'m--',
         linewidth=2)
plt.xlabel('Time (sec)')
plt.ylabel('Displacement (3D, mm)')
plt.title('Toggle 3D: Peak-Valleys')
plt.legend(['Peaks-Valleys (PV)', 'Range of Interest (ROI)'])

fig_name = excel_file[path:extension] + '- Fig Peaks-Valleys 3D-Dir.png'
print(fig_name)

plt.savefig(fig_name)
#files.download(fig_name)

#@title
from sklearn.linear_model import LinearRegression

x = threeD_t_pv.reshape(-1,1)
y = threeD_peak_valleys.reshape(-1,1)
model = LinearRegression().fit(x, y)
threeD_r_2 = model.score(x, y)
threeD_int = model.intercept_[0]
threeD_slope = model.coef_[0][0]
print('coefficient of determination (R-squared):', round(threeD_r_2,4))
print('intercept:', round(threeD_int,4))
print('slope:', round(threeD_slope,4))

#@title
# Generate prediction based on linear regression model
# linear_fit = x * slope + y_int
y_shape = threeD_peak_valleys.shape
y_pred = model.predict(x)
y_pred = y_pred.reshape(y_shape)

"""**Exponential Regression**"""

#@title
x = threeD_t_pv
y = threeD_peak_valleys

threeD_popt, pcov = curve_fit(exponenial_regression, x, y, p0=(1, 1e-3, 1))

xx = np.linspace(threeD_time_start, threeD_time_stop, len(y)+1) 
yy = exponenial_regression(xx, *threeD_popt)

# Calcualting R-squared

residuals = y- exponenial_regression(x, *threeD_popt)
ss_res = np.sum(residuals**2)
ss_tot = np.sum((y - np.mean(y))**2)
threeD_r_2_exp = 1 - (ss_res / ss_tot)

#@title
plt.figure(figsize=(15, 6))
plt.plot(threeD_t_pv, threeD_peak_valleys, '*', threeD_t_pv, y_pred, 'r-', xx, yy, 'k-', linewidth=4)
plt.xlabel('Time (sec)')
plt.ylabel('Displacement (3D, mm)')
plt.title('Toggle 3D: Peak-Valleys')
plt.legend(['Data (PV)','Linear Fit','Exponential Fit'])

fig_name = excel_file[path:extension] + '- Fig Peaks-Valleys Trend 3D-Dir.png'
print(fig_name)

plt.savefig(fig_name)
#files.download(fig_name)

print('\n','                                          Linear Fit: y = x * (', round(threeD_slope,4), ') + (', round(threeD_int,4),')\n')
print('                                                      R-squared: ', round(threeD_r_2,4),'\n')
print('\n','                                Exponential Fit: y = ', round(threeD_popt[0],4), '* exp(', -1*round(threeD_popt[1],4), ' * x) + ', round(threeD_popt[2],4), '\n')
print('                                                      R-squared: ', round(threeD_r_2_exp,4),'\n')

#@title
# Saving parameters 

# We'll use an example of data 'x'
# change it into a data frame before exporting it
# This time sheet_name has an underscore

#data_output = pd.DataFrame(data_output)
#data_output.to_excel('filename.xlsx', sheet_name = 'Parameters')

# Important parameters
# [x_delta_PV, x_peak_valleys, x_t_pv, x_peaks, x_valleys, x_p_t, x_v_t, x_data, x_t_data] 
# print('Change in PV Displacement : ', round(z_delta_PV,4), ' mm')
# print('coefficient of determination (R-squared):', round(r_2,4))
# print('intercept:', round(y_int,4))
# print('slope:', round(slope,4))

data_output_x = {'Toggle Dir': 'X-dir',
     'Time sec (Peaks)': x_p_t,
     'Peaks mm': x_peaks, 
     'Time sec (valleys)': x_v_t,
     'Valleys mm': x_valleys,
     'Time sec (PV)': x_t_pv, 
     'PV': x_peak_valleys}
df_x = pd.DataFrame(data=data_output_x)

data_output_y = {'Toggle Dir': 'Y-dir',
     'Time sec (Peaks)': y_p_t,
     'Peaks mm': y_peaks, 
     'Time sec (valleys)': y_v_t,
     'Valleys mm': y_valleys,
     'Time sec (PV)': y_t_pv,
     'PV mm': y_peak_valleys} 
df_y = pd.DataFrame(data=data_output_y)

data_output_z = {'Toggle Dir': 'Z-dir',
     'Time sec (Peaks)': z_p_t,
     'Peaks mm': z_peaks, 
     'Time sec (valleys)': z_v_t,
     'Valleys mm': z_valleys,
     'Time sec (PV)': z_t_pv,
     'PV mm': z_peak_valleys} 
df_z = pd.DataFrame(data=data_output_z)

data_output_3D = {'Toggle Dir': '3D',
     'Time sec (Peaks)': threeD_p_t,
     'Peaks mm': threeD_peaks, 
     'Time sec (valleys)': threeD_v_t,
     'Valleys mm': threeD_valleys,
     'Time sec (PV)': threeD_t_pv,
     'PV mm': threeD_peak_valleys} 
df_3D = pd.DataFrame(data=data_output_3D)

data_output = {'Toggle Dir': ['X-dir','Y-dir','Z-dir','3D'],
     'Delta PV mm': [x_delta_PV, y_delta_PV, z_delta_PV, threeD_delta_PV],
     'Slope mm/s (Linear)': [x_slope, y_slope, z_slope, threeD_slope], 
     'Intercept (Linear)': [x_int, y_int, z_int, threeD_int],
     'R-squared (Linear)': [x_r_2, y_r_2, z_r_2, threeD_r_2],
     'A mm (Exponential)': [x_popt[0], y_popt[0], z_popt[0], threeD_popt[0]],
     'B mm/s (Exponential)': [x_popt[1], y_popt[1], z_popt[1], threeD_popt[1]],
     'C mm (Exponential)': [x_popt[2], y_popt[2], z_popt[2], threeD_popt[2]],
     'R-squared (Expoential)': [x_r_2_exp, y_r_2_exp, z_r_2_exp, threeD_r_2_exp]} 
df = pd.DataFrame(data=data_output)

output_filename = excel_file[path:extension] + '_Processed.xlsx'
print(output_filename)

#df_t.to_excel(output_filename, sheet_name = 'Data')
#df.to_excel(output_filename, sheet_name = 'Parameters')

with pd.ExcelWriter(output_filename) as writer:    
    # Write each dataframe to a different worksheet.
    df.to_excel(writer, sheet_name='Parameters')
    df_x.to_excel(writer, sheet_name='X-dir')
    df_y.to_excel(writer, sheet_name='Y-dir')
    df_z.to_excel(writer, sheet_name='Z-dir')
    df_3D.to_excel(writer, sheet_name='3D')

#files.download(output_filename)