# -*- coding: utf-8 -*-
# PeakValley_Slopes.ipynb

# Automatically generated by Colaboratory.

# Original file is located at
#    https://colab.research.google.com/drive/1Y6AkpqidK3mFrcigBZfuSxQ3rcGe_H1V

## **Import packages**
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.figure as figure
from matplotlib.widgets import RectangleSelector
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from sklearn.linear_model import LinearRegression
from scipy.optimize import curve_fit
import PySimpleGUI as sg
import os.path

# Window theme
sg.theme('Default1')

# Import .xlsx (cal) file using a file browser
def file_select():
    # Window layout of 2 columns
    file_list_column = [        # Column 1 showing .xlsx files in the selected folder
    [
        sg.Text("File Folder"),
        sg.In(size=(25, 1), enable_events=True, key="-FOLDER-"),
        sg.FolderBrowse(),  # Function to select the folder
        sg.Button('Run')    # Start Button to initiate program
    ],
    [
        sg.Listbox(
            values=[], enable_events=True, size=(40, 20), key="-FILE LIST-"
        )
    ]
]

    # For now will only shw the name of the chosen file
    file_viewer_column = [      # Column 2 showing the name of the chosen .xlsx file
    [sg.Text("Choose a .xlsx file from the list on the left:")],
    [sg.Text(size=(40, 20), key="-TOUT-")],
    [sg.Image(key="-IMAGE-")]
]

    # Full layout (architechure)
    layout = [
    [
        sg.Column(file_list_column),
        sg.VSeparator(),
        sg.Column(file_viewer_column),
    ]
]
    # Window with app icon in top taskbar
    window = sg.Window("File Browser", layout, icon=r'C:\Program Files\Dynamic Load Analyzer\icon.ico')

    # Event loop
    while True:
        event, values = window.read()   # Extract values and button clicks
        if event == sg.WIN_CLOSED:   # If window closes, exit program
            break
        # Folder name was filled in, so make a list of files
        if event == "-FOLDER-":
            folder = values["-FOLDER-"]
            try:
                # Get list of files in the folder, unless folder is empty
                file_list = os.listdir(folder)
            except:
                file_list = []

            fnames = [  # Extract filenames from list of files
                f
                for f in file_list  # Iterate through files in list and extract their paths
                if os.path.isfile(os.path.join(folder, f))
                and f.lower().endswith((".xlsx"))   # Only list .xlsx files in the GUI window
            ]

            window["-FILE LIST-"].update(fnames)    # Update filenames in GUI list

        elif event == "-FILE LIST-":  # If a file was chosen from the list
            try:    # Extract the filename
                filename = os.path.join(
                    values["-FOLDER-"], values["-FILE LIST-"][0]
                )
                window["-TOUT-"].update(filename)   # Display filename in left column of GUI window
                window["-IMAGE-"].update(filename=filename)

            except:
                pass
        elif event == "Run": # Load the selected file into the program
            try:
                excel_file = filename
                if excel_file.find('.') == -1:
                    excel_file = excel_file + '.xlsx'   # Add .xlsx if it is not already in file path

                if excel_file.find('/') == -1:
                    path = 0
                else:
                    path = excel_file.find('/')     # Extract the path for the file

                extension = excel_file.find('.')    # Extract the file ending (i.e. .xlsx)

                # Import file as a dataframe
                data_input = pd.read_excel(excel_file)
                dataset = pd.DataFrame(data_input)

                def extract_data(dataset):
                    # Extract key measurements (time, x- y- z- relatives) as 1D arrays
                    time = np.array(dataset.iloc[:, 0])
                    relative_x = np.array(dataset.iloc[:, 4])
                    relative_y = np.array(dataset.iloc[:, 5])
                    relative_z = np.array(dataset.iloc[:, 6])

                    time_updated = relative_x_updated = relative_y_updated = relative_z_updated = []

                    for i in range(len(time)):  # Iterate through all rows of x- y- z- relatives & remove all empty rows
                        if str(relative_x[i]) != 'nan' and str(relative_y[i]) != 'nan' and str(relative_z[i]) != 'nan':
                            time_updated = np.append(time_updated, time[i])
                            relative_x_updated = np.append(relative_x_updated, relative_x[i])
                            relative_y_updated = np.append(relative_y_updated, relative_y[i])
                            relative_z_updated = np.append(relative_z_updated, relative_z[i])

                    # Update all arrays (empty rows removed)
                    time = np.array(time_updated)
                    relative_x = np.array(relative_x_updated)
                    relative_y = np.array(relative_y_updated)
                    relative_z = np.array(relative_z_updated)

                    # Calculate the scaled relative for each dimension (normalized to initial value)
                    scaled_relative_x = relative_x[:] - relative_x[0]
                    scaled_relative_y = relative_y[:] - relative_y[0]
                    scaled_relative_z = relative_z[:] - relative_z[0]
                    # Calculate 3D displacement (mm)
                    total_distance_3D = np.sqrt(np.square(scaled_relative_x[:]) + np.square(scaled_relative_y[:]) +
                                                np.square(scaled_relative_z[:]))
                    # Rename scaled relatives
                    raw_x = scaled_relative_x
                    raw_y = scaled_relative_y
                    raw_z = scaled_relative_z
                    raw_3D = total_distance_3D

                    return time, raw_x, raw_y, raw_z, raw_3D

                [time, raw_x, raw_y, raw_z, raw_3D] = extract_data(dataset)

                ## **X-Direction** -------------------------------------------------------------------------------------

                # ------------------------------- This is to include a matplotlib figure in a Tkinter canvas
                def draw_figure_w_toolbar(canvas, fig, canvas_toolbar):   # Generate interactive MATLAB figure toolbar
                    if canvas.children:
                        for child in canvas.winfo_children():
                            child.destroy()
                    if canvas_toolbar.children:
                        for child in canvas_toolbar.winfo_children():
                            child.destroy()
                    figure_canvas_agg = FigureCanvasTkAgg(fig, master=canvas)
                    figure_canvas_agg.draw()    # Generate figure canvas
                    toolbar = Toolbar(figure_canvas_agg, canvas_toolbar)    # Generate figure toolbar
                    toolbar.update()    # Update toolbar as it is pressed
                    # Pack toolbar into a specific side of the canvas and size
                    figure_canvas_agg.get_tk_widget().pack(side='right', fill='both', expand=1)

                class Toolbar(NavigationToolbar2Tk):    # Connect toolbar to MATLAB figure
                    def __init__(self, *args, **kwargs):
                        super(Toolbar, self).__init__(*args, **kwargs)

                def region_selector_gui(time, data, dir):
                    # Initiate matplotlib figure
                    fig = figure.Figure()
                    ax = fig.add_subplot(111)   # Actual plot where data will be presented (size = 111)
                    DPI = fig.get_dpi()     # Correcting factor to ensure plot fits in window (IMPORTANT!!!)
                    fig.set_size_inches(505 * 2 / float(DPI), 707 / float(DPI)) # figure size (inch)

                    # Pop-up matplotlib figure to show ROI
                    pop_fig = figure.Figure()   # Pop up plot to show the selected ROI to the user
                    pop_ax = pop_fig.add_subplot(111)
                    pop_DPI = pop_fig.get_dpi()
                    pop_fig.set_size_inches(505 * 2 / float(DPI), 303 / float(DPI))

                    # Draw rectangles to select start-end points
                    def line_select_callback(eclick, erelease):    # Select ROI with mouse (draw a rectangle)
                        global x1, x2       # Variables made global to return them once the function is called

                        # Extract points of click and unclick
                        x1, y1 = eclick.xdata, eclick.ydata
                        x2, y2 = erelease.xdata, erelease.ydata

                        # Remove previous drawn rectangles each time function is called
                        for p in list(ax.patches):  # note the list!
                            p.set_visible(False)
                            p.remove()
                        # Generate rectangle patch at selected ROI
                        rect = plt.Rectangle((min(x1, x2), min(y1, y2)), np.abs(x1 - x2), np.abs(y1 - y2),
                                             edgecolor='k',
                                             facecolor='none',
                                             zorder=2)
                        ax.add_patch(rect)  # Add patch (rectangle) to figure
                        fig.canvas.draw()

                        return x1, x2   # Extract the start and end time points

                    # ------------------------------- PySimpleGUI CODE

                    layout = [
                        [sg.Button('Start', key='-START-')],
                        [sg.Button('Cancel', key='-CANCEL-')],
                        [sg.Button('Submit', key='-SUBMIT-')],
                        [sg.Canvas(key='-CONTROLS_CV-')],
                        [sg.Column(
                            layout=[
                                [sg.Canvas(key='-FIG_CV-',
                                           # it's important that you set this size
                                           size=(500 * 2, 700)
                                           )]
                            ],
                            background_color='#DAE0E6',
                            pad=(0, 0)  # Pad image with 0's
                        )],
                        [sg.Text("Vertical axis: Time (sec) ; Horizontal axis: Displacement (mm)")],
                        [sg.Text(
                            "Press 'Start' to show plot. Then use the mouse to hover over the desired starting point. "
                            "Then left click and drag the mouse to the desired stopping point.")],
                        [sg.Text(" Then unclick and press 'Submit'.")]
                    ]

                    window = sg.Window('Select Region of Interest (ROI) for the ' + dir + '-dir', layout,
                                       icon=r'C:\Program Files\Dynamic Load Analyzer\icon.ico')

                    while True:
                        count = 0   # Counter to keep track if x1 and x2 are returned (rectangle is drawn)
                        event, values = window.read()

                        # If user presses 'Cancel' or closes window, close app
                        if event == '-CANCEL-' or event == sg.WIN_CLOSED:
                            break

                        # If user presses 'Start', show plot and allow them to draw rectangles
                        elif event == '-START-':
                            # Matlibplot of data
                            raw_plt = ax.plot(time, data)

                            rs = RectangleSelector(ax, line_select_callback,
                                                   drawtype='box', useblit=False, button=[1],
                                                   minspanx=5, minspany=5, spancoords='pixels', interactive=True)
                            # Update figure with drawn rectangle (ROI)
                            draw_figure_w_toolbar(window['-FIG_CV-'].TKCanvas, fig, window['-CONTROLS_CV-'].TKCanvas)

                        # If user presses 'Submit', have popup asking them to continue
                        elif event == '-SUBMIT-':
                            choice = sg.Window('Continue?', [[sg.Text('Do you want to continue?')],
                                                             [sg.Button('Show Plot', key='-SHOW_PLOT-')],
                                                             [sg.Button('Yes', key='-YES-')],
                                                             [sg.Button('No', key='-NO-')],
                                                             [sg.Canvas(key='-POPUP_CONTROLS-')],
                                                             [sg.Column(layout=[
                                                                 [sg.Canvas(key='-POPUP_FIG-', size=(500 * 2, 300))]],
                                                                        background_color='#DAE0E6', pad=(0, 0))],
                                                             [sg.Text(
                                                                 "Vertical axis: Time (sec) ;"
                                                                 " Horizontal axis: Displacement "
                                                                 "(X-dir, mm)")],
                                                             [sg.Text(
                                                                 "Press 'Start' to show plot. Then use the mouse to "
                                                                 "hover over "
                                                                 "the desired starting point.Then left click and drag "
                                                                 "the mouse "
                                                                 "to the desired stopping point. Then unclick and press "
                                                                 "'Submit'"
                                                                 ".")]],
                                               icon=r'C:\Program Files\Dynamic Load Analyzer\icon.ico')
                            while True:
                                event, values = choice.read()
                                # User must press 'Show Plot' to see the ROI on the figure
                                if event == '-SHOW_PLOT-':
                                    pop_plt = pop_ax.plot(time, data, [x1, x1, x1, x1, x1],
                                                          np.linspace(np.min(data), np.max(data), 5), 'm--',
                                                          [x2, x2, x2, x2, x2],
                                                          np.linspace(np.min(data), np.max(data), 5), 'm--')
                                    draw_figure_w_toolbar(choice['-POPUP_FIG-'].TKCanvas, pop_fig,
                                                          choice['-POPUP_CONTROLS-'].TKCanvas)

                                # If user presses 'No', popup will close and they'll be prompted to redraw rectangle
                                elif event == '-NO-':
                                    break

                                # If user presses 'Yes', the ROI will be fed through the following functions
                                else:
                                    time_start = x1
                                    time_stop = x2
                                    count = 1   # Confirmed that user wants to continue
                                    break
                            # Close windows and figures
                            choice.close()
                            pop_ax.clear()
                            if count == 1:
                                break

                    window.close()

                    return time_start, time_stop

                x_time_start, x_time_stop = region_selector_gui(time, raw_x, dir='X')

                # -----------------------------------------------------------------------------------------

                def Selected_time_range(time_start, time_stop): # Extract index of start and end time points in ROI

                    delta_start = abs(time - time_start)
                    delta_stop = abs(time - time_stop)

                    # Find the index of the time points that most closesly match the user defined time points
                    start = np.where(delta_start == min(delta_start))[0][0]
                    stop = np.where(delta_stop == min(delta_stop))[0][0]

                    return start, stop

                [start, stop] = Selected_time_range(x_time_start, x_time_stop)

                # Make variables global to call through multiple functions without returning
                global smooth_ans, winsize_input, satisfied_ans

                # ------------------------------------------------------------------------------------------------------
                def reion_of_interest_gui(time, data, dir): # Ask user if they would like to smooth the data in ROI
                    # instantiate matplotlib figure
                    fig = figure.Figure()
                    ax = fig.add_subplot(111)
                    DPI = fig.get_dpi()
                    fig.set_size_inches(505 * 2 / float(DPI), 707 / float(DPI))

                    # ------------------------------- PySimpleGUI CODE

                    layout = [
                        [sg.Button('Show Plot', key='-SHOW_PLOT-')],
                        [sg.Text("Would you like to Smooth Data?")],
                        [sg.Button('YES', key='-YES-')],
                        [sg.Button('NO', key='-NO-')],
                        [sg.Canvas(key='-CONTROLS_CV-')],
                        [sg.Column(
                            layout=[
                                [sg.Canvas(key='-FIG_CV-',
                                           # it's important that you set this size
                                           size=(500 * 2, 700)
                                           )]
                            ],
                            background_color='#DAE0E6',
                            pad=(0, 0)
                        )],
                        [sg.Text("Vertical axis: Time (sec) ; Horizontal axis: Displacement (" + dir + "-dir, mm)")],
                        [sg.Text(
                            "Press 'Show Plot' to show plot. Then use the mouse to hover over the desired starting point. "
                            "Then left click and drag the mouse to the desired stopping point.")],
                        [sg.Text("Then unclick and press 'Submit'. Press 'Cancel' or the close out tap to exit when"
                                 " ready to move forward")]
                    ]

                    window = sg.Window('Select Region of Interest (ROI) for ' + dir + '-dir', layout,
                                       icon=r'C:\Program Files\Dynamic Load Analyzer\icon.ico')

                    while True:
                        event, values = window.read()
                        # If user closes window, assume they do not want to smooth data
                        if event == sg.WIN_CLOSED:
                            break

                        # User must press 'Show Plot' to see plot
                        elif event == '-SHOW_PLOT-':
                            # Matlibplot of data
                            raw_plt = ax.plot(time[start:stop], data[start:stop])
                            draw_figure_w_toolbar(window['-FIG_CV-'].TKCanvas, fig, window['-CONTROLS_CV-'].TKCanvas)

                        # If user presses 'Yes' prompt the user to enter an integer for the window size
                        elif event == '-YES-':
                            smooth_ans = 'YES'
                            satisfied_ans = 0
                            winsize_input = sg.popup_get_text('Window Size', 'Please enter window size (integer):')

                            count = 0 # Counter to find any letters in user input

                            # Iterate through user input and prompt error message if input is not an integer
                            for i in winsize_input:
                                if i.isdigit():
                                    pass
                                else:
                                    count = count + 1
                            if count > 0:
                                sg.popup('Invalid:  Please enter an integer for the window size.')
                            else:
                                winsize = int(winsize_input)    # Convert user input from string to integer
                                break   # Close window and move on

                        # If user presses 'No', move forward without smoothing data
                        elif event == '-NO-':
                            smooth_ans = 'NO'
                            winsize = 0
                            satisfied_ans = 1   # Counter to indicate that user is statisfied with the data in ROI
                            break

                    window.close()
                    return smooth_ans, winsize, satisfied_ans

                # ----------------------------------------------------------------------------------------------------------------------
                def smoothen(x, winsize):   # Smooth data in ROI
                    return np.array(pd.Series(x).rolling(winsize).mean())[winsize - 1:]

                # ----------------------------------------------------------------------------------------------------------------------
                def smoothed_data(smooth_ans, satisfied_ans, winsize, x_start, x_stop, time, raw_x, raw_y, raw_z,
                                  raw_3D, dir):
                    # If user has specified to smooth the data, smooth for all directions (x-,y-,z-) and 3D disp.
                    if smooth_ans == 'YES':
                        temp_time = smoothen(time, winsize)
                        temp_raw_x = smoothen(raw_x, winsize)
                        temp_raw_y = smoothen(raw_y, winsize)
                        temp_raw_z = smoothen(raw_z, winsize)
                        temp_raw_3D = smoothen(raw_3D, winsize)

                        # Define the direction for the plots
                        if dir == 'X':
                            # temp_raw_plt = plt.plot(temp_time, temp_raw_x)
                            temp_raw = temp_raw_x
                        elif dir == 'Y':
                            temp_raw = temp_raw_y
                        elif dir == 'Z':
                            temp_raw = temp_raw_z
                        elif dir == '3D':
                            temp_raw = temp_raw_3D

                        # Initiate matplotlib figure
                        fig = figure.Figure()
                        ax = fig.add_subplot(111)
                        DPI = fig.get_dpi()
                        fig.set_size_inches(505 * 2 / float(DPI), 707 / float(DPI))

                        # ------------------------------- PySimpleGUI CODE

                        layout = [
                            [sg.Text("Smoothed Data:")],
                            [sg.Button('Show Plot', key='-SHOW_PLOT-')],
                            [sg.Text("Satisfied? :")],
                            [sg.Button('YES', key='-YES-')],
                            [sg.Button('NO', key='-NO-')],
                            [sg.Canvas(key='-CONTROLS_CV-')],
                            [sg.Column(
                                layout=[
                                    [sg.Canvas(key='-FIG_CV-',
                                               # it's important that you set this size
                                               size=(500 * 2, 700)
                                               )]
                                ],
                                background_color='#DAE0E6',
                                pad=(0, 0)
                            )],
                            [sg.Text(
                                "Vertical axis: Time (sec) ; Horizontal axis: Displacement (" + dir + "-dir, mm)")],
                            [sg.Text(
                                "Press 'Show plot' to show plot. Then unclick and press 'Submit'. Press 'Cancel' or the "
                                "close out tap to exit when ready to move forward")]
                        ]

                        window = sg.Window('Smoothed Region of Interest (ROI) for ' + dir + '-dir', layout,
                                           icon=r'C:\Program Files\Dynamic Load Analyzer\icon.ico')

                        while True:
                            event, values = window.read()
                            # If user closes window, assume they are satisfied with the smoothed data
                            if event == sg.WIN_CLOSED:
                                satisfied_ans = 1
                                break

                            # User must press 'Show Plot' to view the plot
                            elif event == '-SHOW_PLOT-':
                                # Matlibplot of data
                                temp_plt = ax.plot(temp_time[x_start:x_stop], temp_raw[x_start:x_stop])
                                draw_figure_w_toolbar(window['-FIG_CV-'].TKCanvas, fig,
                                                      window['-CONTROLS_CV-'].TKCanvas)

                            # If user presses 'Yes', they are satisified with the smoothed data and will move on
                            elif event == '-YES-':
                                # Update all data arrays with smoothed data
                                time = temp_time
                                raw_x = temp_raw_x
                                raw_y = temp_raw_y
                                raw_z = temp_raw_z
                                raw_3D = temp_raw_3D
                                satisfied_ans = 1
                                break   # close window

                            # If user presses 'No', they are unsatisfied with the smoothed data and will be prompted to
                            # re-select the ROI and re-smooth the data
                            elif event == '-NO-':
                                satisfied_ans = 0
                                break

                        window.close()
                    return time, raw_x, raw_y, raw_z, raw_3D, satisfied_ans

                satisfied_ans = 0   # Counter to indicate if user is satisfied with data
                while satisfied_ans == 0:   # Iterate through loop as long as user is unsatisfied with the data
                    smooth_ans, winsize, satisfied_ans = reion_of_interest_gui(time, raw_x, dir='X')
                    time, raw_x, raw_y, raw_z, raw_3D, satisfied_ans = smoothed_data(smooth_ans, satisfied_ans, winsize,
                                                                                     start,
                                                                                     stop, time, raw_x, raw_y, raw_z,
                                                                                     raw_3D, dir='X')

                # Find the peaks & valleys in the ROI
                def Select_data_range(start, stop, raw_data):

                    # Extract ROI based on start and end time points
                    y_start = start
                    y_stop = stop
                    y_data = raw_data[y_start:y_stop]
                    t_data = time[y_start:y_stop]

                    peaks = valleys = p_t = v_t = np.array([])

                    # Iterate through all rows
                    for i in range(len(y_data) - 1):
                        if i > 0 and i < len(y_data) - 2:   # look at everything but the ends of the ROI
                            if y_data[i] > y_data[i - 2] and y_data[i] > y_data[i - 1] and y_data[i] > y_data[i + 1] and \
                                    y_data[i] > y_data[i + 2]:
                            # If y-value at index is greater than the 2 before of it and after it than it's a peak
                                peaks_new = y_data[i]
                                p_t_new = t_data[i]
                                peaks = np.append(peaks, peaks_new)
                                p_t = np.append(p_t, p_t_new)

                            # If y-value at index is less than the 2 before of it and after it than it's a valley
                            elif y_data[i] < y_data[i - 2] and y_data[i] < y_data[i - 1] and y_data[i] < y_data[
                                i + 1] and y_data[i] < y_data[i + 2]:
                                valleys_new = y_data[i]
                                v_t_new = t_data[i]
                                valleys = np.append(valleys, valleys_new)
                                v_t = np.append(v_t, v_t_new)

                        elif i == 0:    # Look at the first index of the ROI
                            # If y-value at index is greater than the 3 after it than it's a peak
                            if y_data[i] > y_data[i + 1] and y_data[i] > y_data[i + 2] and y_data[i] > y_data[i + 3]:
                                peaks_new = y_data[i]
                                p_t_new = t_data[i]
                                peaks = np.append(peaks, peaks_new)
                                p_t = np.append(p_t, p_t_new)

                            # If y-value at index is less than the 3 after it than it's a valley
                            elif y_data[i] < y_data[i + 1] and y_data[i] < y_data[i + 2] and y_data[i] < y_data[i + 3]:
                                valleys_new = y_data[i]
                                v_t_new = t_data[i]
                                valleys = np.append(valleys, valleys_new)
                                v_t = np.append(v_t, v_t_new)

                        elif i == len(y_data) - 2:  # Look at the second-to-last index of the ROI
                            # If y-value at index is greater than the 2 before and 1 after it than it's a peak
                            if y_data[i] > y_data[i - 1] and y_data[i] > y_data[i - 2] and y_data[i] > y_data[i + 1]:
                                peaks_new = y_data[i]
                                p_t_new = t_data[i]
                                peaks = np.append(peaks, peaks_new)
                                p_t = np.append(p_t, p_t_new)

                            # If y-value at index is less than the 2 before and 1 after than it's a valley
                            elif y_data[i] < y_data[i - 1] and y_data[i] < y_data[i - 2] and y_data[i] < y_data[i + 1]:
                                valleys_new = y_data[i]
                                v_t_new = t_data[i]
                                valleys = np.append(valleys, valleys_new)
                                v_t = np.append(v_t, v_t_new)

                        elif i == len(y_data) - 1:  # Look at the last index of the ROI

                            # If y-value at index is greater than the 3 before it than it's a peak
                            if y_data[i] > y_data[i - 1] and y_data[i] > y_data[i - 2] and y_data[i] > y_data[i - 3]:
                                peaks_new = y_data[i]
                                p_t_new = t_data[i]
                                peaks = np.append(peaks, peaks_new)
                                p_t = np.append(p_t, p_t_new)

                            # If y-value at index is greater than the 3 before it than it's a valley
                            elif y_data[i] < y_data[i - 1] and y_data[i] < y_data[i - 2] and y_data[i] < y_data[i - 3]:
                                valleys_new = y_data[i]
                                v_t_new = t_data[i]
                                valleys = np.append(valleys, valleys_new)
                                v_t = np.append(v_t, v_t_new)

                        if peaks.shape[0] > 0 and valleys.shape[0] > 0: # Make sure that there are peaks and valleys
                            thresh = 50 # threshold (mm) of displacement (rel to starting position) that will be
                            # considered in the analysis, this should be changed depending on the application

                            # If the y-value (peak or valley) is greater than this threshold, the peak/valley
                            # will be null
                            if peaks[len(peaks) - 1] >= thresh or valleys[len(valleys) - 1] <= -thresh:
                                peaks = peaks[:-1]
                                valleys = valleys[:-1]
                                p_t = p_t[:-1]
                                v_t = v_t[:-1]

                    # Need to make sure the # of peaks = # of valleys
                    if len(peaks) > len(valleys):   # If more peaks than valleys, remove the peak that has doesn't
                        # match up to the time point of a valley
                        diff = len(peaks) - len(valleys)
                        new_peaks = new_valleys = new_p_t = new_v_t = []
                        for j in range(len(p_t)):
                            pv_pair = abs(v_t - p_t[j])
                            # Find index of the peaks closest to the particular valley in terms of time
                            pair_idx = np.where(pv_pair == min(pv_pair))[0][0]

                            # Update peak, valley, time of peak and valley (p_t, v_t) arrays
                            if abs(v_t[pair_idx] - p_t[j]) <= 1:
                                new_v_t = np.append(v_t[pair_idx], new_v_t)
                                new_valleys = np.append(valleys[pair_idx], new_valleys)
                                new_p_t = np.append(p_t[j], new_p_t)
                                new_peaks = np.append(peaks[j], new_peaks)

                        p_t = new_p_t
                        peaks = new_peaks
                        v_t = new_v_t
                        valleys = new_valleys

                    elif len(peaks) < len(valleys):   # If more valleys than peaks, remove the valley that has doesn't
                        # match up to the time point of a valley

                        diff = len(valleys) - len(peaks)
                        new_peaks = new_valleys = new_p_t = new_v_t = []
                        for j in range(len(v_t)):
                            pv_pair = abs(p_t - v_t[j])
                            # Find index of the peaks closest to the particular valley in terms of time
                            pair_idx = np.where(pv_pair == min(pv_pair))[0][0]

                            # Update peak, valley, time of peak and valley (p_t, v_t) arrays
                            if abs(p_t[pair_idx] - v_t[j]) <= 1:
                                new_p_t = np.append(p_t[pair_idx], new_p_t)
                                new_peaks = np.append(peaks[pair_idx], new_peaks)
                                new_v_t = np.append(v_t[j], new_v_t)
                                new_valleys = np.append(valleys[j], new_valleys)

                        p_t = new_p_t
                        peaks = new_peaks
                        v_t = new_v_t
                        valleys = new_valleys

                    peak_valleys = abs(peaks - valleys)

                    # Take the time of the inflection point (flip between peak and valley) as
                    # the time point for PV
                    stack = np.vstack((p_t, v_t))  # Create an (n,2) array
                    t_pv = abs((p_t - v_t) / 2) + np.min(stack, axis=0)  # find average between time
                    # points of peak and valley, then add that average to the lowest time point
                    # of the two (offset)

                    # Find the difference between peaks and valleys (y-values)
                    delta_PV = abs(peak_valleys[1] - peak_valleys[len(peak_valleys) - 20])  # look at all but the last
                    # 20 indexes to account for possible overhang in the ROI that was unintended by the user
                    return delta_PV, peak_valleys, t_pv, peaks, valleys, p_t, v_t, y_data, t_data

                [x_delta_PV, x_peak_valleys, x_t_pv, x_peaks, x_valleys, x_p_t, x_v_t, x_data, x_t_data] = \
                    Select_data_range(start, stop, raw_x)

                # Plot peaks & valleys for ROI
                def PV_plots(time, raw_data, peak_valleys, t_pv, peaks, valleys, p_t, v_t, excel_file, path, extension,
                             dir):
                    # Configure matlibplot showing raw data with peaks and valleys overlayed
                    raw_x_plt = plt.plot(time, raw_data, p_t, peaks, v_t, valleys)
                    plt.xlabel('Time (sec)')
                    plt.ylabel('Displacement (' + dir + '-dir, mm)')
                    plt.legend(['Raw Displacement (' + dir + '-dir)', 'Peaks', 'Valleys'])
                    plt.show()

                    # Plot and save matlibplot of raw data for future reference
                    plt.figure(figsize=(20, 9))
                    plt.plot(time, raw_data, linewidth=1)
                    plt.plot(p_t, peaks, 'r-', v_t, valleys, 'g-', linewidth=0.8)
                    plt.plot([t_pv[1], t_pv[1], t_pv[1], t_pv[1], t_pv[1]],
                             np.linspace(np.min(raw_data), np.max(raw_data), 5), 'm--',
                             [t_pv[len(t_pv) - 20], t_pv[len(t_pv) - 20], t_pv[len(t_pv) - 20],
                              t_pv[len(t_pv) - 20], t_pv[len(t_pv) - 20]],
                             np.linspace(np.min(raw_data), np.max(raw_data), 5), 'm--', linewidth=2)
                    plt.xlabel('Time (sec)')
                    plt.ylabel('Displacement (' + dir + '-dir, mm)')
                    plt.title('Toggle ' + dir + '-dir')
                    plt.legend(['Raw Disp. (' + dir + '-dir)', 'Peaks', 'Valleys', 'Range of Interest (ROI)'])

                    fig_name = excel_file[path:extension] + '- Fig Raw-' + dir + ' Data.png'
                    plt.savefig(fig_name)
                    plt.show()
                    plt.close()

                    # Plot just the peaks ('o-') and valleys ('*-')
                    plt.figure(figsize=(15, 8))
                    plt.plot(p_t, peaks, 'o-', v_t, valleys, '*-')
                    plt.xlabel('Time (sec)')
                    plt.ylabel('Displacement (' + dir + '-dir, mm)')
                    plt.title('Toggle ' + dir + '-dir')
                    plt.legend(['Peaks', 'Valleys'])

                    fig_name = excel_file[path:extension] + '- Fig Peaks vs. Valley ' + dir + '-Dir.png'
                    plt.savefig(fig_name)
                    plt.show()
                    plt.close()

                    # Plot the difference between peaks and valleys (delta_PV) and the ROI
                    plt.figure(figsize=(15, 6))
                    plt.plot(t_pv, peak_valleys, '*', [t_pv[1], t_pv[1], t_pv[1], t_pv[1], t_pv[1]],
                             np.linspace(np.min(peak_valleys), np.max(peak_valleys), 5), 'm--',
                             [t_pv[len(t_pv) - 20], t_pv[len(t_pv) - 20], t_pv[len(t_pv) - 20],
                              t_pv[len(t_pv) - 20], t_pv[len(t_pv) - 20]],
                             np.linspace(np.min(peak_valleys), np.max(peak_valleys), 5), 'm--', linewidth=2)
                    plt.xlabel('Time (sec)')
                    plt.ylabel('Displacement (' + dir + '-dir, mm)')
                    plt.title('Toggle ' + dir + '-dir: Peak-Valleys')
                    plt.legend(['Peak-Valleys (PV)', 'Region of Interest (ROI)'])

                    fig_name = excel_file[path:extension] + '- Fig Peak-Valleys ' + dir + '-Dir.png'
                    plt.savefig(fig_name)
                    plt.show()
                    plt.close()

                PV_plots(time, raw_x, x_peak_valleys, x_t_pv, x_peaks, x_valleys, x_p_t, x_v_t, excel_file, path,
                         extension, dir='X')

                # -------------------------------------------------------- **Regression**
                def PV_regression(peak_valleys, t_pv, excel_file, path, extension, dir):
                    # ---------------------------------------------------- **Linear Regression**
                    # Reshape time and data vectors for delta_PV to feed into ML kernel
                    x = t_pv.reshape(-1, 1)
                    y = peak_valleys.reshape(-1, 1)
                    model = LinearRegression().fit(x, y)    # fit linear model to data using regression
                    r_2 = model.score(x, y)     # R-squared of linear fit
                    y_int = model.intercept_[0] # y-intercept of liner fit
                    slope = model.coef_[0][0]   # slope of linear fit

                    # Generate prediction based on linear regression model
                    # linear_fit = x * slope + y_int
                    y_shape = peak_valleys.shape
                    y_pred = model.predict(x)
                    # Extract prediction based on linear model
                    y_pred = y_pred.reshape(y_shape)

                    # ---------------------------------------------------- **Exponential Regression**
                    def exponenial_regression(x, a, b, c):  # Function defining mathematics for decaying exponential
                        return a * np.exp(-b * x) + c

                    # Redefine inputs (delta_PV)
                    x = t_pv
                    y = peak_valleys

                    def tolerance(exponenial_regression, x, y): # Make user able to re-define tolerances of curve_fit()
                        # function in the event that convergence of variables (a, b, c) is not possible
                        layout = [[sg.Text('Please manually enter an absolute tolerance (e.g. 1e-6):')],
                                  [sg.Text('Tol:', size=(15, 1)), sg.InputText()],
                                  [sg.Button('Ok', key='-OK-')],
                                  [sg.Button('Cancel', key='-CANCEL-')]
                                  ]

                        window = sg.Window('Exponential Regression', layout,
                                           icon=r'C:\Program Files\Dynamic Load Analyzer\icon.ico')

                        while True:
                            event, values = window.read()
                            # If the user presses 'Cancel' or closes window, present a warning that the following data
                            # will not be fitted with an exponential regression model
                            if event == '-CANCEL-' or event == sg.WIN_CLOSED:
                                sg.popup('Warming: Exponential regression will not be run for this direction.')
                                popt, pcov = 0, 0   # Default values for coefficent arrays in case the user decides to
                                # move on without performing an exponential regression
                                break

                            # If the user presses 'Ok', the absolute tolerance entered will be used to find convergence
                            # of the coefficients (a, b, c)
                            elif event == '-OK-':
                                tol = float(values[0])  # Convert user input from string to float

                                try: # If the curve_fit() function executes without issue, close window and move on
                                    popt, pcov = curve_fit(exponenial_regression, x, y, p0=(1, tol, 1))
                                    break
                                except (RuntimeError, TypeError, ValueError, NameError):
                                    # If the curve_fit() function encounters any kind of error, prompt the user to enter
                                    # a new absolute tolerance
                                    sg.popup('Exponential Regression',
                                             'Error: Optimal parameters not found. Please enter a different'
                                             ' absolute tolerance (e.g. 1e-4):')

                        window.close()
                        return popt, pcov

                    thresh = 0  # Counter to determine if the user wants to have an exponential regression model
                    while True:
                        try:    # Run the exponential regression assuming a default tolerance of 1e-3
                            popt, pcov = curve_fit(exponenial_regression, x, y, p0=(1, 1e-3, 1))
                            thresh = 1  # If there are no errors (i.e. convergence), then close the window and move on
                            break
                        except (RuntimeError, TypeError, ValueError, NameError):    # If the program encounters errors,
                            # prompt the user to enter a new abolsute tolerance and re-run regression until
                            # convergence is found, or the user decides to cancel and move on without regression
                            popt, pcov = tolerance(exponenial_regression, x, y)
                            break

                    if thresh == 1:     # If exponential regression is possibile and selected by the user, plot models
                        xx = np.linspace(x_time_start, x_time_stop, len(y) + 1)
                        yy = exponenial_regression(xx, *popt)

                        # Calculating R-squared
                        residuals = y - exponenial_regression(x, *popt)
                        ss_res = np.sum(residuals ** 2)
                        ss_tot = np.sum((y - np.mean(y)) ** 2)
                        r_2_exp = 1 - (ss_res / ss_tot)

                        plt.figure(figsize=(15, 6))
                        plt.plot(t_pv, peak_valleys, '*', t_pv, y_pred, 'r-', xx, yy, 'k-', linewidth=4)
                        plt.xlabel('Time (sec)')
                        plt.ylabel('Displacement (' + dir + '-dir, mm)')
                        plt.title('Toggle' + dir + '-dir: Peak-Valleys')
                        plt.legend(
                            ['Peak-Valleys (PV)', 'Linear Fit: $R^2$ = ' + str(round(r_2, 2)),
                             'Exponential Fit: $R^2$ = ' + str(round(r_2_exp, 2))])

                    else:
                        r_2_exp = 'NaN'     # Indicates that exponential regression was non-covergent
                        plt.figure(figsize=(15, 6))
                        plt.plot(t_pv, peak_valleys, '*', t_pv, y_pred, 'r-', linewidth=4)
                        plt.xlabel('Time (sec)')
                        plt.ylabel('Displacement (' + dir + '-dir, mm)')
                        plt.title('Toggle' + dir + '-dir: Peak-Valleys')
                        plt.legend(['Peak-Valleys (PV)', 'Linear Fit: $R^2$ = ' + str(round(r_2, 2))])

                    # Save regression figure
                    fig_name = excel_file[path:extension] + '- Fig Peak-Valleys Trend ' + dir + '-Dir.png'
                    plt.savefig(fig_name)
                    plt.show()
                    plt.close()

                    # print('\n','                                          Linear Fit: y = x * (', round(slope,4), ')
                    # + (', round(y_int,4),')\n')
                    # print('                                                      R-squared: ', round(r_2,4),'\n')
                    # if thresh == 1:
                    #    print('\n','                                Exponential Fit: y = ', round(popt[0],4),
                    #    '* exp(', -1*round(popt[1],4), ' * x) + ', round(popt[2],4), '\n')
                    # print('                                                      R-squared: ',
                    #    round(r_2_exp,4),'\n')

                    return popt, r_2, r_2_exp, y_int, slope

                [x_popt, x_r_2, x_r_2_exp, x_int, x_slope] = PV_regression(x_peak_valleys, x_t_pv, excel_file, path,
                                                                           extension, dir='X')

                ## **Y-Direction** -------------------------------------------------------------------------------------

                # Find the peaks, valleys, time points for peaks and valleys, and delta_PVs for the y-dir data
                # using the SAME ROI used for the x-dir data
                y_delta_PV, y_peak_valleys, y_t_pv, y_peaks, y_valleys, y_p_t, y_v_t, y_data, y_t_data = \
                    Select_data_range(start, stop, raw_y)

                # Plot peaks & valleys for ROI
                PV_plots(time, raw_y, y_peak_valleys, y_t_pv, y_peaks, y_valleys, y_p_t, y_v_t, excel_file, path,
                         extension, dir='Y')

                # ---------------------------------------------------- **Regression**
                [y_popt, y_r_2, y_r_2_exp, y_int, y_slope] = PV_regression(y_peak_valleys, y_t_pv, excel_file, path,
                                                                           extension, dir='Y')

                ## **Z-Direction** -------------------------------------------------------------------------------------

                # Find the peaks, valleys, time points for peaks and valleys, and delta_PVs for the z-dir data
                # using the SAME ROI used for the x-dir data
                z_delta_PV, z_peak_valleys, z_t_pv, z_peaks, z_valleys, z_p_t, z_v_t, z_data, z_t_data = \
                    Select_data_range(start, stop, raw_z)

                # Plot peaks & valleys for ROI
                PV_plots(time, raw_z, z_peak_valleys, z_t_pv, z_peaks, z_valleys, z_p_t, z_v_t, excel_file, path,
                         extension, dir='Z')

                # ---------------------------------------------------- **Regression**
                [z_popt, z_r_2, z_r_2_exp, z_int, z_slope] = PV_regression(z_peak_valleys, z_t_pv, excel_file, path,
                                                                           extension, dir='Z')

                ## **3D-Displacement** ---------------------------------------------------------------------------------

                # Find the peaks, valleys, time points for peaks and valleys, and delta_PVs for the 3D-disp. data
                # using the SAME ROI used for the x-dir data
                threeD_delta_PV, threeD_peak_valleys, threeD_t_pv, threeD_peaks, threeD_valleys, threeD_p_t, \
                threeD_v_t, threeD_data, threeD_t_data = Select_data_range(start, stop, raw_3D)

                # Plot peaks & valleys for ROI
                PV_plots(time, raw_3D, threeD_peak_valleys, threeD_t_pv, threeD_peaks, threeD_valleys, threeD_p_t,
                         threeD_v_t,
                         excel_file, path, extension, dir='3D')

                # ---------------------------------------------------- **Regression**
                [threeD_popt, threeD_r_2, threeD_r_2_exp, threeD_int, threeD_slope] = PV_regression(threeD_peak_valleys,
                                                                                                    threeD_t_pv,
                                                                                                    excel_file,
                                                                                                    path, extension,
                                                                                                    dir='3D')

                ## **3D-Displacement** ---------------------------------------------------------------------------------
                # We'll use an example of data 'x'
                # change it into a data frame before exporting it
                # This time sheet_name has an underscore

                # data_output = pd.DataFrame(data_output)
                # data_output.to_excel('filename.xlsx', sheet_name = 'Parameters')

                # Important parameters
                # [delta_PV, peak_valleys, t_pv, peaks, valleys, p_t, v_t, data, t_data]
                # print('Change in PV Displacement : ', round(z_delta_PV,4), ' mm')
                # print('coefficient of determination (R-squared):', round(r_2,4))
                # print('intercept:', round(y_int,4))
                # print('slope:', round(slope,4))

                data_output_x = {'Toggle Dir': 'X-dir',
                                 'Time sec (Peaks)': x_p_t,
                                 'Peaks mm': x_peaks,
                                 'Time sec (valleys)': x_v_t,
                                 'Valleys mm': x_valleys,
                                 'Time sec (PV)': x_t_pv,
                                 'PV': x_peak_valleys}
                df_x = pd.DataFrame(data=data_output_x)

                data_output_y = {'Toggle Dir': 'Y-dir',
                                 'Time sec (Peaks)': y_p_t,
                                 'Peaks mm': y_peaks,
                                 'Time sec (valleys)': y_v_t,
                                 'Valleys mm': y_valleys,
                                 'Time sec (PV)': y_t_pv,
                                 'PV mm': y_peak_valleys}
                df_y = pd.DataFrame(data=data_output_y)

                data_output_z = {'Toggle Dir': 'Z-dir',
                                 'Time sec (Peaks)': z_p_t,
                                 'Peaks mm': z_peaks,
                                 'Time sec (valleys)': z_v_t,
                                 'Valleys mm': z_valleys,
                                 'Time sec (PV)': z_t_pv,
                                 'PV mm': z_peak_valleys}
                df_z = pd.DataFrame(data=data_output_z)

                data_output_3D = {'Toggle Dir': '3D',
                                  'Time sec (Peaks)': threeD_p_t,
                                  'Peaks mm': threeD_peaks,
                                  'Time sec (valleys)': threeD_v_t,
                                  'Valleys mm': threeD_valleys,
                                  'Time sec (PV)': threeD_t_pv,
                                  'PV mm': threeD_peak_valleys}
                df_3D = pd.DataFrame(data=data_output_3D)

                data_output = {'Toggle Dir': ['X-dir', 'Y-dir', 'Z-dir', '3D'],
                               'Delta PV mm': [x_delta_PV, y_delta_PV, z_delta_PV, threeD_delta_PV],
                               'Slope mm/s (Linear)': [x_slope, y_slope, z_slope, threeD_slope],
                               'Intercept (Linear)': [x_int, y_int, z_int, threeD_int],
                               'R-squared (Linear)': [x_r_2, y_r_2, z_r_2, threeD_r_2],
                               'A mm (Exponential)': [x_popt[0], y_popt[0], z_popt[0], threeD_popt[0]],
                               'B mm/s (Exponential)': [x_popt[1], y_popt[1], z_popt[1], threeD_popt[1]],
                               'C mm (Exponential)': [x_popt[2], y_popt[2], z_popt[2], threeD_popt[2]],
                               'R-squared (Exponential)': [x_r_2_exp, y_r_2_exp, z_r_2_exp, threeD_r_2_exp]}
                df = pd.DataFrame(data=data_output)

                output_filename = excel_file[path:extension] + '_Processed.xlsx'
                # print(output_filename)

                # df_t.to_excel(output_filename, sheet_name = 'Data')
                # df.to_excel(output_filename, sheet_name = 'Parameters')

                with pd.ExcelWriter(output_filename) as writer:
                    # Write each dataframe to a different worksheet.
                    df.to_excel(writer, sheet_name='Parameters')
                    df_x.to_excel(writer, sheet_name='X-dir')
                    df_y.to_excel(writer, sheet_name='Y-dir')
                    df_z.to_excel(writer, sheet_name='Z-dir')
                    df_3D.to_excel(writer, sheet_name='3D')

            except:
                sg.popup('Error: Please select a file')

    window.close()

file_select()

